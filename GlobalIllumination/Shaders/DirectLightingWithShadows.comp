
layout (location = 0) uniform sampler2D worldPosition;//RGBA32F
layout (location = 1) uniform sampler2D worldNormal;
layout (location = 2) uniform sampler2D albedo;
layout (location = 3) uniform sampler2D specMap;
layout (location = 4) uniform sampler2D depthMap;

layout(location = 0) uniform image2D albedoWithLightAndShadow;

void main() {
    ivec2 size = textureSize(worldPosition, 0);
    ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
    if(xy.x < size.x && xy.y < size.y) {
        vec3 wcPosition = texelFetch(worldPosition, xy, 0).xyz;
        vec3 wcNormal = normalize(texelFetch(worldNormal, xy, 0).xyz);
        vec4 color = texelFetch(albedo, xy, 0);
        float shininess = texelFetch(specMap, xy, 0).r;
        vec3 lightVec;
        vec3 viewVec = normalize(camPosition.xyz - wcPosition);
        if(LightPosition.w == 0.0f) {
            lightVec = -normalize(LightPosition.xyz);
        } else {
            lightVec = normalize(LightPosition.xyz - wcPosition);
        }
        
        vec3 reflectVec = reflect(-lightVec, wcNormal);
        float N_L = max(0.0, dot(wcNormal, lightVec));
        float R_V = max(0.0, dot(reflectVec, viewVec));
        float spec = (R_V == 0.0) ? 0.0 : pow(R_V, shininess);
        vec3 diffuse = color * N_L * LightPower.r;
        vec3 specular = color * spec * LightPower.r;
        float visibleFactor = 1.0f;
        vec4 shadowCoords = ShadowMatrix * vec4(wcPosition, 1.0f);
        if(texture(depthMap, shadowCoords.xy).r < shadowCoords.z-0.005f) {
            visibleFactor = 0.0f;
        }
        imageStore(albedoWithLightAndShadow, xy, vec4(visibleFactor * (color + specular), 1.0f));
    }
}