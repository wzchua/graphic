#version 450
#extension GL_ARB_shader_atomic_counter_ops : require

layout (local_size_x = 512) in;
layout(binding = 0) uniform atomic_uint fragListPtr;
//initlized at 9
layout(binding = 1) uniform atomic_uint nodePtr;
// 0
layout(binding = 2) uniform atomic_uint brickPtrX;
layout(binding = 3) uniform atomic_uint brickPtrY;

struct FragmentStruct {
    vec4 position;
    vec4 color;
};

layout(binding = 0) buffer FragmentListBlock {
    FragmentStruct frag[];
};

layout(binding = 1) buffer FragmentListBlock2 {
    FragmentStruct frag2[];
};

struct NodeStruct {
    uint childPtr;
    uint brickPtrX;
    uint brickPtrY;
};

layout(binding = 2) volatile buffer NodeBlock {
    NodeStruct node[];
};
struct SyncStruct {
    uint treadInvoked;
};

layout(binding = 3) coherent buffer SyncBlock {
    SyncStruct sync[];
};

layout(binding = 0, RGBA8) uniform image3D texture3D;
layout(binding = 1, r32ui) uniform uimage3D lock3D;

uniform uint noOfFragments;

bool isToTerminate = false;
uniform uint ISPROCESS = 0 - 1;
uniform uint LEAF = 0 - 2;

void deferFragment() {
    uint index = atomicCounterIncrement(fragListPtr);
    frag2[index] = frag[gl_GlobalInvocationID.x];
    isToTerminate = true;
}

uint getPtrOffset(ivec3 frameOffset) {
    return min(frameOffset.x, 1) * 1 
    + min(frameOffset.y, 1) * 2 + min(frameOffset.z, 1) * 4;
}

uniform float levels[10] = float[10](0.001953125f, 0.00390625f, 0.0078125f,
                                0.015625f, 0.03125f, 0.0625f,
                                0.125f, 0.25f, 0.5f, 1.0f);

ivec3[10] computeLevelOffset() {
    ivec3 frameOffset = ivec3(0);
    ivec3 prevFrameOffset = ivec3(0);
    ivec3 levelOffsets[10];
    vec3 position = vec3(frag[gl_GlobalInvocationID.x].position);
    for(int i = 0; i < 10; i++) {
        prevFrameOffset = frameOffset * 2;
        frameOffset = ivec3(position * levels[i]);
        levelOffsets[i] = frameOffset - prevFrameOffset;
    }
    return levelOffsets;
} 

uint enterNode(uint nodeIndex, uint offset) {
    uint childIndex = atomicCompSwap(node[nodeIndex].childPtr, 0, ISPROCESS);
    if(childIndex == 0) {
        memoryBarrier();
        childIndex = atomicCounterAddARB(nodePtr, 8);
        atomicCompSwap(node[nodeIndex].childPtr, ISPROCESS, childIndex);
        node[nodeIndex].brickPtrX = atomicCounterIncrement(brickPtrX);
        memoryBarrier();        
        return childIndex + offset;
    } else if(childIndex == ISPROCESS) {
        deferFragment();
        return ISPROCESS;
    } else {
        atomicCompSwap(node[nodeIndex].childPtr, ISPROCESS, childIndex);
        return childIndex + offset;
    }
}

uint enterLeaf(uint nodeIndex, uint offset) {
    uint childIndex = atomicCompSwap(node[nodeIndex].childPtr, 0, ISPROCESS);
    if(childIndex == 0) {
        memoryBarrier();
        childIndex = atomicCounterAddARB(nodePtr, 8);
        atomicCompSwap(node[nodeIndex].childPtr, ISPROCESS, childIndex);
        for(int i = 0; i < 8; i++) {
            atomicCompSwap(node[childIndex + i].childPtr, 0, LEAF);
        }
        node[nodeIndex].brickPtrX = atomicCounterIncrement(brickPtrX);
        node[childIndex + offset].brickPtrX = atomicCounterIncrement(brickPtrX);
        memoryBarrier();        
        return childIndex + offset;
    } else if(childIndex == ISPROCESS) {
        deferFragment();
        return ISPROCESS;
    } else {
        atomicCompSwap(node[nodeIndex].childPtr, ISPROCESS, childIndex);
        return childIndex + offset;
    }
}

void main() {
    //frag position in 0 to 512 range
    if(gl_GlobalInvocationID.x < noOfFragments) {
        ivec3 levelOffsets[10] = computeLevelOffset();
        int maxLevel = 9;

        uint nodeIndex = 0;
        //bool isOkay = true;
        //isOkay = generateNode(nodeIndex);
        //if(!isOkay) { return; }
        nodeIndex = enterNode(nodeIndex, getPtrOffset(levelOffsets[0]));
        if(nodeIndex == ISPROCESS){
            return;
        }

        for(int i = 1; i < maxLevel; i++) {            
            nodeIndex = enterNode(nodeIndex, getPtrOffset(levelOffsets[i]));
            if(nodeIndex == ISPROCESS){
                return;
            }
            //nodeIndex = node[nodeIndex].childPtr + getPtrOffset(levelOffsets[i]); 
            //isOkay = generateNode(nodeIndex);
            //if(!isOkay) { return; }
        }
        nodeIndex = enterLeaf(nodeIndex, getPtrOffset(levelOffsets[maxLevel]));
        if(nodeIndex == ISPROCESS){
            return;
        }
        //if(isOkay) {
        //    isOkay = generateLeaf(nodeIndex, node[nodeIndex].childPtr + getPtrOffset(levelOffsets[maxLevel]));
        //}
        //if(!isOkay) { return; }
    }
    
    /*
    uint bx = node[nodeIndex].brickPtrX & 0xFF;
    uint by = node[nodeIndex].brickPtrX >> 16;    
    ivec innerFrameOffset = levelOffsets[8];
    ivec3 texturePos = ivec3(bx + innerFrameOffset.x, by + innerFrameOffset.y, innerFrameOffset.z);
    
    uint Used = 0 - 1;
    uint value = 0;
    //lock mutex
    while((value = imageAtomicExchange(lock3D, texturePos, Used)) == Used) {  }
    vec4 prevColor = imageLoad(texture3D, texturePos);
    vec4 avgColor = (prevColor * value + fragment.color) / (value + 1);
    imageStore(texture3D, texturePos, avgColor);
    //release mutex
    imageAtomicExchange(lock3D, texturePos, (value + 1));
    */
    
}