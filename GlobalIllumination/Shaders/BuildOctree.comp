#version 450
#extension GL_ARB_shader_atomic_counter_ops : require

layout (local_size_x = 512) in;
layout(binding = 0) uniform atomic_uint fragListPtr;
//initlized at 9
layout(binding = 1) uniform atomic_uint nodePtr;
// 0
layout(binding = 2) uniform atomic_uint brickPtrX;
layout(binding = 3) uniform atomic_uint brickPtrY;

struct FragmentStruct {
    vec4 position;
    vec4 color;
};

layout(binding = 0) buffer FragmentListBlock {
    FragmentStruct frag[];
};

layout(binding = 1) buffer FragmentListBlock2 {
    FragmentStruct frag2[];
};

struct NodeStruct {
    uint childPtr;
    uint brickPtrX;
    uint brickPtrY;
};

layout(binding = 2) volatile buffer NodeBlock {
    NodeStruct node[];
};
struct SyncStruct {
    uint treadInvoked;
};

layout(binding = 3) coherent buffer SyncBlock {
    SyncStruct sync[];
};

layout(binding = 0, RGBA8) uniform image3D texture3D;
layout(binding = 1, r32ui) uniform uimage3D lock3D;

const int length = 400;
const int width = 400;

uniform uint noOfFragments;

bool isToTerminate = false;

void deferFragment() {
    uint id = gl_GlobalInvocationID.x;
    FragmentStruct fragment = frag[id];
    uint index = atomicCounterIncrement(fragListPtr);
    frag2[index] = fragment;
    isToTerminate = true;
}

uint getChildPtr(uint parentPtr, ivec3 frameOffset) {
    //map to node space where voxel center is at corner
    ivec3 nodeOffset;
    nodeOffset.x = min(frameOffset.x, 1);
    nodeOffset.y = min(frameOffset.y, 1);
    nodeOffset.z = min(frameOffset.z, 1);
    uint ptrOffset = nodeOffset.x * 1 + nodeOffset.y * 2 + nodeOffset.z * 4;

    return ptrOffset + node[parentPtr].childPtr;
}

void generateNode(uint parentPtr) {
    uint isGenerating = atomicCompSwap(sync[parentPtr].treadInvoked, 0, 1);
    if(isGenerating == 0) {
        node[parentPtr].childPtr = atomicCounterAddARB(nodePtr, 8);
        node[parentPtr].brickPtrX = atomicCounterIncrement(brickPtrX);
        atomicCompSwap(sync[parentPtr].treadInvoked, 1, 2);    
    }
    if(isGenerating == 1) {
        deferFragment();
    } else if(isGenerating == 2) {
        
    }
}

void generateLeaf(uint parentPtr, uint leafPtr) {
    uint isGenerating = atomicCompSwap(sync[parentPtr].treadInvoked, 2, 3);
    if(isGenerating == 2) {     
        uint childPtr = node[parentPtr].childPtr;
        for(int i = 0; i < 8; i++) {
            node[childPtr + i].brickPtrY = 0 - 1;
        }
        atomicCompSwap(sync[parentPtr].treadInvoked, 3, 4);    
    } else if(isGenerating < 2) {
        deferFragment();
        return;
    }

    uint isGenerating2 = atomicCompSwap(sync[leafPtr].treadInvoked, 0, 1);
    if(isGenerating2 == 0) {   
        if(node[leafPtr].brickPtrX == 0) {
            node[leafPtr].brickPtrX = atomicCounterIncrement(brickPtrX);
        }
        atomicCompSwap(sync[leafPtr].treadInvoked, 1, 4);  
    } else if(isGenerating2 == 1) {
        deferFragment();
    } else if(isGenerating2 == 2) {
        
    }
}

uniform float levels[10] = float[10](0.001953125f, 0.00390625f, 0.0078125f,
                                0.015625f, 0.03125f, 0.0625f,
                                0.125f, 0.25f, 0.5f, 1.0f);

ivec3[10] computeLevelOffset(FragmentStruct fragment) {
    ivec3 frameOffset = ivec3(0);
    ivec3 prevFrameOffset = ivec3(0);
    ivec3 levelOffsets[10];
    for(int i = 0; i < 10; i++) {
        prevFrameOffset = frameOffset * 2;
        frameOffset = ivec3(fragment.position * levels[i]);
        levelOffsets[i] = frameOffset - prevFrameOffset;
    }
    return levelOffsets;
} 

void main() {
    //frag position in 0 to 512 range
    uint id = gl_GlobalInvocationID.x;
    if(id < noOfFragments) {
        FragmentStruct fragment = frag[id];
        ivec3 levelOffsets[10];
        levelOffsets = computeLevelOffset(fragment);
        int maxLevel = 3;

        uint nodeIndex = 0;
        generateNode(nodeIndex);

        for(int i = 1; i < maxLevel; i++) {
            nodeIndex = getChildPtr(nodeIndex, levelOffsets[i]); 
            generateNode(nodeIndex);
            if(isToTerminate) { return; }
        }
        generateLeaf(nodeIndex, getChildPtr(nodeIndex, levelOffsets[maxLevel]));
        if(isToTerminate) { return; }
    }
    
    /*
    uint bx = node[nodeIndex].brickPtrX & 0xFF;
    uint by = node[nodeIndex].brickPtrX >> 16;    
    ivec innerFrameOffset = levelOffsets[8];
    ivec3 texturePos = ivec3(bx + innerFrameOffset.x, by + innerFrameOffset.y, innerFrameOffset.z);
    
    uint Used = 0 - 1;
    uint value = 0;
    //lock mutex
    while((value = imageAtomicExchange(lock3D, texturePos, Used)) == Used) {  }
    vec4 prevColor = imageLoad(texture3D, texturePos);
    vec4 avgColor = (prevColor * value + fragment.color) / (value + 1);
    imageStore(texture3D, texturePos, avgColor);
    //release mutex
    imageAtomicExchange(lock3D, texturePos, (value + 1));
    */
    
}