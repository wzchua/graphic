#version 450
#extension GL_ARB_shader_atomic_counter_ops : require

layout (local_size_x = 512) in;
layout(binding = 0) uniform atomic_uint fragListPtr;
//initlized at 9
layout(binding = 1) uniform atomic_uint nodePtr;
// 0
layout(binding = 2) uniform atomic_uint brickPtrX;
layout(binding = 3) uniform atomic_uint brickPtrY;

struct FragmentStruct {
    vec4 position;
    vec4 color;
};

layout(binding = 0) buffer FragmentListBlock {
    FragmentStruct frag[];
};

layout(binding = 1) buffer FragmentListBlock2 {
    FragmentStruct frag2[];
};

struct NodeStruct {
    uint childPtr;
    uint brickPtrX;
    uint brickPtrY;
};

layout(binding = 2) volatile buffer NodeBlock {
    NodeStruct node[];
};
struct SyncStruct {
    uint treadInvoked;
};

layout(binding = 3) coherent buffer SyncBlock {
    SyncStruct sync[];
};

layout(binding = 0, RGBA8) uniform image3D texture3D;
layout(binding = 1, r32ui) uniform uimage3D lock3D;

const int length = 400;
const int width = 400;

uniform uint noOfFragments;

bool isToTerminate = false;

void deferFragment() {
    uint id = gl_GlobalInvocationID.x;
    FragmentStruct fragment = frag[id];
    uint index = atomicCounterIncrement(fragListPtr);
    frag2[index] = fragment;
    isToTerminate = true;
}

uint getChildPtr(uint parentPtr, ivec3 frameOffset) {
    //map to node space where voxel center is at corner
    ivec3 nodeOffset;
    nodeOffset.x = min(frameOffset.x, 1);
    nodeOffset.y = min(frameOffset.y, 1);
    nodeOffset.z = min(frameOffset.z, 1);
    uint ptrOffset = nodeOffset.x * 1 + nodeOffset.y * 2 + nodeOffset.z * 4;

    return ptrOffset + node[parentPtr].childPtr;
}

void generateNode(uint parentPtr, bool isLeaf) {
    barrier();
    memoryBarrier();
    if(node[parentPtr].childPtr != 0) {
        return;
    }
    uint isGenerating = atomicCompSwap(sync[parentPtr].treadInvoked, 0, 1);
    if(isGenerating == 1) {
        deferFragment();
        return;
    } else if(isGenerating == 2) {
        return;
    }
    if(!isLeaf) {
        atomicExchange(node[parentPtr].childPtr, atomicCounterAddARB(nodePtr, 8));
    }
    node[parentPtr].brickPtrX = atomicCounterIncrement(brickPtrX);
    atomicCompSwap(sync[parentPtr].treadInvoked, 1, 2);    
}

uniform float levels[9] = float[9](0.001953125f, 0.00390625f, 0.0078125f,
                                0.015625f, 0.03125f, 0.0625f,
                                0.125f, 0.25f, 0.5f);
                                
ivec3[9] computeLevelOffset(FragmentStruct fragment) {
    ivec3 frameOffset = ivec3(0);
    ivec3 prevFrameOffset = ivec3(0);
    ivec3 levelOffsets[9];
    for(int i = 0; i < 9; i++) {
        prevFrameOffset = frameOffset * 2;
        frameOffset = ivec3(fragment.position * levels[i]);
        levelOffsets[i] = frameOffset - prevFrameOffset;
    }
    return levelOffsets;
} 

void main() {
    //frag position in 0 to 512 range
    uint id = gl_GlobalInvocationID.x;
    memoryBarrier();
    if(id >= noOfFragments) {
        return;
    }
    FragmentStruct fragment = frag[id];
    uint nodeIndex = 0;
    ivec3 levelOffsets[9];
    levelOffsets = computeLevelOffset(fragment);
    //root node is pregenerated
    for(int i = 1; i < 9; i++) {        
        nodeIndex = getChildPtr(nodeIndex, levelOffsets[i]);
        generateNode(nodeIndex, i == 8);
        if(isToTerminate) { return; }
    }
    
    /*
    uint bx = node[nodeIndex].brickPtrX * 3;
    uint by = node[nodeIndex].brickPtrY * 3;    
    ivec3 texturePos = ivec3(bx + innerFrameOffset.x, by + innerFrameOffset.y, innerFrameOffset.z);
    
    uint Used = 0 - 1;
    uint value = 0;
    //lock mutex
    while((value = imageAtomicExchange(lock3D, texturePos, Used)) == Used) {  }
    vec4 prevColor = imageLoad(texture3D, texturePos);
    vec4 avgColor = (prevColor * value + fragment.color) / (value + 1);
    imageStore(texture3D, texturePos, avgColor);
    //release mutex
    imageAtomicExchange(lock3D, texturePos, (value + 1));
    */
}