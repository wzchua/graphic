layout(binding = 0) uniform sampler3D colorBrickL0;
layout(binding = 1) uniform sampler3D normalBrickL0;
layout(binding = 2) uniform sampler3D lightDirBrickL0;
layout(binding = 3) uniform usampler3D lightEnergyBrickL0;
layout(binding = 4) uniform sampler3D colorBrickL1;
layout(binding = 5) uniform sampler3D normalBrickL1;
layout(binding = 6) uniform sampler3D lightDirBrickL1;
layout(binding = 7) uniform usampler3D lightEnergyBrickL1;
layout(binding = 8) uniform sampler3D colorBrickL2;
layout(binding = 9) uniform sampler3D normalBrickL2;
layout(binding = 10) uniform sampler3D lightDirBrickL2;
layout(binding = 11) uniform usampler3D lightEnergyBrickL2;

layout(binding = 12) uniform sampler2D gbufferWorldPosition;
layout(binding = 13) uniform sampler2D gbufferNormal;
layout(binding = 14) uniform sampler2D gbufferAlbedo;
layout(binding = 15) uniform sampler2D gbufferSpec;

layout(binding = 0, rgba8) uniform image2D indirectAlbedo;

#define PI           3.14159265358979323846

struct GaussianLobe {
    vec3 amplitude;
    vec3 axis;
    float sharpness;
};
//https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/
//http://www.jp.square-enix.com/tech/library/pdf/Fast%20Indirect%20illumination%20Using%20Two%20Virtual%20Spherical%20Gaussian%20Lights%20(Supplemental%20Material).pdf
GaussianLobe generateSG(vec3 amplitude, vec3 mean) {
    GaussianLobe g;
    g.amplitude = amplitude;
    g.axis = normalize(mean);
    float len = min(length(mean), 0.9999f);
    g.sharpness = len / (1.0f - len); //Toksvig's filtering
    return g;
}

GaussianLobe Product(GaussianLobe g1, GaussianLobe g2) {
    GaussianLobe g;
    float l = g1.sharpness + g2.sharpness;
    vec3 u = (g1.sharpness * g1.axis + g2.sharpness * g2.axis) / (l);
    float uLength = length(u);

    g.axis = u * (1.0f / uLength);
    g.sharpness = l * uLength;
    g.amplitude = g1.amplitude * g2.amplitude * exp(l * (uLength - 1.0f));
    return g;
}

vec3 InnerProduct(GaussianLobe g1, GaussianLobe g2) {
    float uLength = length(g1.sharpness * g1.axis + g2.sharpness * g2.axis);
    float eFactorized = exp(uLength - g1.sharpness - g2.sharpness);
    float factorized2 = 1.0f - exp(-2.0f * uLength);
    return (2.0f * PI * g1.amplitude * g2.amplitude * eFactorized * factorized2) / uLength;
}
//inputPos in world space
int findMinLevel(vec3 inputPos) {    
    int level;
    if(inputPos.x < level1min.x || inputPos.x > level1max.x
        || inputPos.y < level1min.y || inputPos.y > level1max.y
        || inputPos.z < level1min.z || inputPos.z > level1max.z) {        
        level = 2;
    } else if(inputPos.x < level0min.x || inputPos.x > level0max.x
        || inputPos.y < level0min.y || inputPos.y > level0max.y
        || inputPos.z < level0min.z || inputPos.z > level0max.z) {
        level = 1;
    } else {
        level = 0;
    }
    return level;
}

bool isWithinBoundary(vec3 inputPos) {
    if(inputPos.x < level2min.x || inputPos.x > level2max.x
        || inputPos.y < level2min.y || inputPos.y > level2max.y
        || inputPos.z < level2min.z || inputPos.z > level2max.z) {
            return false;
    } 
    return true;
}
float evaluateLOD(float degree, float len) {
    return log2(2 * len * tan(radians(degree)));
}
vec4 evaluateColor(in sampler3D colorClip, in sampler3D normalClip, in sampler3D lightDirClip, 
    in usampler3D lightEnergyClip, float lod, vec3 clipPos, GaussianLobe viewLobe) {
        vec4 color = vec4(0.0f);
        vec4 c = textureLod(colorClip, clipPos, lod);
        if(c.a > 0.0f) {                
            vec4 n = 2.0f * textureLod(normalClip, clipPos, lod) - 1.0f;
            uint lEnergy = textureLod(lightEnergyClip, clipPos, lod).r;
            vec4 l = 2.0f * textureLod(lightDirClip, clipPos, lod) - 1.0f;
            GaussianLobe normalLobe = generateSG(vec3(1.0f), n.xyz);
            GaussianLobe lightLobe = generateSG(vec3(1.0f), l.xyz);

            vec3 brdf = c.rgb / PI;
            vec3 convLightNormal = max(InnerProduct(viewLobe, Product(normalLobe, lightLobe)), 0.0f);

            color.rgb = brdf * float(lEnergy)/134217727.0f * convLightNormal;
            color.a = c.a;
        }
        return color;
    }
// origin & dir in world space
vec3 diffuseConeTrace(vec3 origin, vec3 dir, float angle) {
    if(!isWithinBoundary(origin)) {
        return vec3(0.0);
    }
    float alpha = 0.0f;
    int level = findMinLevel(origin);
    vec3 adjustedDir = pow(2, level) * dir; // lengthen dir when traversing through larger grid dim
    vec3 rayVoxelPos = origin + adjustedDir;
    float lod; vec4 clipPos;

    float cosPhi = cos(radians(angle));
    GaussianLobe viewLobe;
    viewLobe.amplitude = vec3(1.0f);
    viewLobe.axis = -dir;
    viewLobe.sharpness = 1.0f/(cosPhi * cosPhi);
    vec3 color = vec3(0.0f);
    vec4 c;
    int i = 0;
    while(alpha < 1.0f && isWithinBoundary(rayVoxelPos) && i < 256) {
        i++;
        float len = length(rayVoxelPos - origin);
        lod = evaluateLOD(angle/2.0f, len);
        // if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
        //     logFragment(vec4(gl_GlobalInvocationID.xy, len, lod), vec4(rayVoxelPos, lod), uint(findMinLevel(rayVoxelPos)), uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), uint(i));
        // }
        //adjustedDir = pow(2, lod) * dir;
        if(lod < 1.0f) {
            clipPos = (voxelToClipmapL0Mat * vec4(rayVoxelPos, 1.0f));
            clipPos = clipPos/clipPos.w / 128.0f;
            c = evaluateColor(colorBrickL0, normalBrickL0, lightDirBrickL0, lightEnergyBrickL0, lod, clipPos.xyz, viewLobe);
        } else if(lod < 2.0f) {
            clipPos = (voxelToClipmapL1Mat * vec4(rayVoxelPos, 1.0f));
            clipPos = clipPos/clipPos.w / 128.0f;
            lod = lod - 1.0f;
            c = evaluateColor(colorBrickL1, normalBrickL1, lightDirBrickL1, lightEnergyBrickL1, lod, clipPos.xyz, viewLobe);
        } else {
            clipPos = (voxelToClipmapL2Mat * vec4(rayVoxelPos, 1.0f));
            clipPos = clipPos/clipPos.w / 128.0f;
            lod = lod - 2.0f;
            c = evaluateColor(colorBrickL2, normalBrickL2, lightDirBrickL2, lightEnergyBrickL2, lod, clipPos.xyz, viewLobe);
        }
        color += (1.0f - alpha) * c.rgb ;/// (len * len);
        alpha = alpha + (1.0f - alpha) * c.a;        
        rayVoxelPos += adjustedDir;
    }
    return color;
}

vec3 findOrthoVector(vec3 v) {
    vec3 u = cross(v, vec3(1, 0, 0));
    if(abs(dot(u, v)) == 1.0f) {
        u = cross(v, vec3(0, 1, 0));
    }
    return u;
}

const float voxelDim = 511.0f;
void main() 
{   
    ivec2 size = textureSize(gbufferWorldPosition, 0);
    ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
    
    if(xy.x < size.x && xy.y < size.y) {
        vec4 gbPos = texelFetch(gbufferWorldPosition, xy, 0);
        vec4 gbNormal = texelFetch(gbufferNormal, xy, 0);
        vec4 gbColor = texelFetch(gbufferAlbedo, xy, 0);
        float gbSpec = texelFetch(gbufferSpec, xy, 0).r;
        vec3 pos = (WorldToVoxelMat * gbPos).xyz;
        // 4x 60 from normal + 1 at normal;
        vec3 normal = normalize(gbNormal.xyz * 2.0f - 1.0f);
        vec3 orthoX = findOrthoVector(normal);
        vec3 orthoY = normalize(cross(normal, orthoX));
        float diffuseAngle = 70.0f;
        vec3 diffuseColor = 0.2f * diffuseConeTrace(pos, normal, diffuseAngle);
        diffuseColor += 0.2f * diffuseConeTrace(pos, normalize(mix(normal, orthoX, 0.7)), diffuseAngle);
        diffuseColor += 0.2f * diffuseConeTrace(pos, normalize(mix(normal, -orthoX, 0.7)), diffuseAngle);
        diffuseColor += 0.2f * diffuseConeTrace(pos, normalize(mix(normal, orthoY, 0.7)), diffuseAngle);
        diffuseColor += 0.2f * diffuseConeTrace(pos, normalize(mix(normal, -orthoY, 0.7)), diffuseAngle);
        vec3 view  = normalize(pos - camPosition.xyz);    
        vec3 specularColor = vec3(0.0f);
        /*if(shininess > 0.0f) {
            specularColor = specularConeTrace(pos, reflect(view, normal), shininess);
        }*/
        imageStore(indirectAlbedo, xy, vec4(gbColor.rgb * (diffuseColor + specularColor), 1.0f));
    }
}