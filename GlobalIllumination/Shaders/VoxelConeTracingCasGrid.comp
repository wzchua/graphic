layout(binding = 0) uniform sampler3D colorBrickL0;
layout(binding = 1) uniform sampler3D normalBrickL0;
layout(binding = 2) uniform sampler3D lightDirBrickL0;
layout(binding = 3) uniform usampler3D lightEnergyBrickL0;
layout(binding = 4) uniform sampler3D colorBrickL1;
layout(binding = 5) uniform sampler3D normalBrickL1;
layout(binding = 6) uniform sampler3D lightDirBrickL1;
layout(binding = 7) uniform usampler3D lightEnergyBrickL1;
layout(binding = 8) uniform sampler3D colorBrickL2;
layout(binding = 9) uniform sampler3D normalBrickL2;
layout(binding = 10) uniform sampler3D lightDirBrickL2;
layout(binding = 11) uniform usampler3D lightEnergyBrickL2;

layout(binding = 12) uniform sampler2D gbufferWorldPosition;
layout(binding = 13) uniform sampler2D gbufferNormal;
layout(binding = 14) uniform sampler2D gbufferAlbedo;
layout(binding = 15) uniform sampler2D gbufferSpec;

layout(binding = 0, rgba8) uniform image2D indirectAlbedo;

#define PI           3.14159265358979323846
vec3 normal;
vec4 originL0;
vec4 originL1;
vec4 originL2;
struct GaussianLobe {
    vec3 amplitude;
    vec3 axis;
    float sharpness;
};
//https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/
//http://www.jp.square-enix.com/tech/library/pdf/Fast%20Indirect%20illumination%20Using%20Two%20Virtual%20Spherical%20Gaussian%20Lights%20(Supplemental%20Material).pdf
GaussianLobe generateSG(vec3 amplitude, vec3 mean) {
    GaussianLobe g;
    g.amplitude = amplitude;
    g.axis = normalize(mean);
    float len = min(length(mean), 0.99f);
    g.sharpness = len / (1.0f - len); //Toksvig's filtering
    return g;
}

GaussianLobe Product(GaussianLobe g1, GaussianLobe g2) {
    GaussianLobe g;
    float l = g1.sharpness + g2.sharpness;
    vec3 u = (g1.sharpness * g1.axis + g2.sharpness * g2.axis) / (l);
    float uLength = length(u);

    g.axis = u * (1.0f / uLength);
    g.sharpness = l * uLength;
    g.amplitude = g1.amplitude * g2.amplitude * exp(l * (uLength - 1.0f));
    return g;
}

vec3 InnerProduct(GaussianLobe g1, GaussianLobe g2) {
    float uLength = length(g1.sharpness * g1.axis + g2.sharpness * g2.axis);
    float eFactorized = exp(uLength - g1.sharpness - g2.sharpness);
    float factorized2 = 1.0f - exp(-2.0f * uLength);
    return (2.0f * PI * g1.amplitude * g2.amplitude * eFactorized * factorized2) / uLength;
}
//inputPos in world space
int findMinLevel(vec3 inputPos) {    
    int level;
    if(inputPos.x < level1min.x || inputPos.x > level1max.x
        || inputPos.y < level1min.y || inputPos.y > level1max.y
        || inputPos.z < level1min.z || inputPos.z > level1max.z) {        
        level = 2;
    } else if(inputPos.x < level0min.x || inputPos.x > level0max.x
        || inputPos.y < level0min.y || inputPos.y > level0max.y
        || inputPos.z < level0min.z || inputPos.z > level0max.z) {
        level = 1;
    } else {
        level = 0;
    }
    return level;
}

bool isWithinBoundary(vec3 inputPos) {
    if(inputPos.x < level2min.x || inputPos.x > level2max.x
        || inputPos.y < level2min.y || inputPos.y > level2max.y
        || inputPos.z < level2min.z || inputPos.z > level2max.z) {
            return false;
    } 
    return true;
}
float evaluateLOD(float degree, float len, out float width) {
    width = 2 * len * tan(radians(degree));
    return log2(width);
}
vec3 evaluateShadingFactorDiffuseSG(vec4 normal, vec4 lightDir, float energy, GaussianLobe viewLobe) {
    GaussianLobe normalLobe = generateSG(vec3(1.0f), normal.xyz);
    GaussianLobe lightLobe = generateSG(vec3(energy), lightDir.xyz);

    return max(InnerProduct(normalLobe, lightLobe), 0.0f);
}
vec3 evaluateShadingFactorDiffusePhong(vec4 normal, vec4 lightDir, float lEnergy, GaussianLobe viewLobe) {    

    return vec3(lEnergy) ;//* max(dot(normalize(normal.xyz), normalize(lightDir.xyz)), 0.0f);
}
vec4 texelFetchInterpolated(in sampler3D clipGrid, vec3 clipPos, float lod) {
        int lodfloor = int(floor(lod));
        int lodCeil = int(ceil(lod));
        vec3 floorPos = clipPos / float(1 << lodfloor);
        vec3 ceilPos = clipPos / float(1 << lodCeil);
        //return mix(texelFetch(clipGrid, ivec3(floorPos), lodfloor), texelFetch(clipGrid, ivec3(ceilPos), lodCeil), lod - float(lodfloor));
        //return texelFetch(clipGrid, ivec3(floorPos), lodfloor);
        return textureLod(clipGrid, (clipPos)/128.0f, lod);
}
vec4 texelFetchInterpolatedU(in usampler3D clipGrid, vec3 clipPos, float lod) {
        int lodfloor = int(floor(lod));
        int lodCeil = int(ceil(lod));
        vec3 floorPos = clipPos / float(1 << lodfloor);
        vec3 ceilPos = clipPos / float(1 << lodCeil);
        //return mix(texelFetch(clipGrid, ivec3(floorPos), lodfloor), texelFetch(clipGrid, ivec3(ceilPos), lodCeil), lod - float(lodfloor));
        //return texelFetch(clipGrid, ivec3(floorPos), lodfloor);
        return textureLod(clipGrid, (clipPos)/128.0f, lod);
}
vec4 evaluateColor(in sampler3D colorClip, in sampler3D normalClip, in sampler3D lightDirClip, 
    in usampler3D lightEnergyClip, float lod, vec3 clipPos, GaussianLobe viewLobe) {
        vec4 color = vec4(0.0f);
        int lodInt = int(floor(lod));
        vec4 c = texelFetchInterpolated(colorClip, clipPos, lod);
        if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
            logFragment(c, vec4(clipPos, lod), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
        }
        if(c.a > 0.0f) {         
            color.a = c.a;       
            float lEnergy = float(texelFetchInterpolatedU(lightEnergyClip, clipPos, lod).r)/8388607.0f;
            // if(lEnergy == 0.0f) {
            //     return color;
            // }
            vec4 n = texelFetchInterpolated(normalClip, clipPos, lod);
            vec4 l =  texelFetchInterpolated(lightDirClip, clipPos, lod);
            vec3 brdf = c.rgb / PI;
            //vec3 convLightNormal = evaluateShadingFactorDiffuseSG(n, l, lEnergy, viewLobe);
            vec3 convLightNormal = evaluateShadingFactorDiffusePhong(n, l, lEnergy, viewLobe);
            
            if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
                logFragment(vec4(l.xyz, lEnergy), n, textureLod(lightEnergyClip, clipPos, lod).r, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
                logFragment(c, vec4(convLightNormal, dot(normalize(n.xyz), normalize(l.xyz))), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
            }
            color.rgb = brdf * convLightNormal;
        }
        return color;
    }
    bool isNextToEachOther(ivec3 clipPos1, ivec3 clipPos2) {
        ivec3 diff = abs(clipPos1 - clipPos2);
        return diff.x <= 2 && diff.y <=2 && diff.z <=2;
    }
// origin & dir in world space
vec3 diffuseConeTrace(vec3 origin, vec3 dir, float angle) {
    if(!isWithinBoundary(origin)) {
        return vec3(0.0);
    }
    float alpha = 0.0f;
    int level = findMinLevel(origin);
    vec3 adjustedDir = pow(2, level) * dir; // lengthen dir when traversing through larger grid 
    vec3 rayVoxelPos = origin + adjustedDir;
    float lod; vec4 clipPos;

    float cosPhi = cos(radians(angle));
    GaussianLobe viewLobe;
    viewLobe.amplitude = vec3(1.0f);
    viewLobe.axis = -dir;
    viewLobe.sharpness = 1.0f/(cosPhi * cosPhi);
    vec3 color = vec3(0.0f);
    vec4 c;
    int i = 0;
    while(alpha < 1.0f && isWithinBoundary(rayVoxelPos) && i < 512) {
        i++;
        float len = length(rayVoxelPos - origin);
        float width;
        lod = max(evaluateLOD(angle/2.0f, len, width), float(findMinLevel(rayVoxelPos)));
        if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
            logFragment(vec4(dir, alpha), vec4(rayVoxelPos, lod), uint(findMinLevel(rayVoxelPos)), uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), uint(i));
        }
        adjustedDir = width * dir;
        if(lod < 1.0f) {
            clipPos = (voxelToClipmapL0Mat * vec4(rayVoxelPos, 1.0f));
            clipPos = clipPos/clipPos.w;
            if(originL0.w != 0.0f && isNextToEachOther(ivec3(clipPos.xyz), ivec3(originL0.xyz))) {
                c = vec4(0.0f);
            }else {
                c = evaluateColor(colorBrickL0, normalBrickL0, lightDirBrickL0, lightEnergyBrickL0, lod, clipPos.xyz, viewLobe);
            }
        } else if(lod < 2.0f) {
            clipPos = (voxelToClipmapL1Mat * vec4(rayVoxelPos, 1.0f));
            clipPos = clipPos/clipPos.w;
            if(originL1.w != 0.0f && isNextToEachOther(ivec3(clipPos.xyz), ivec3(originL1.xyz))) {
                c = vec4(0.0f);
            }else {                
                lod = lod - 1.0f;
                c = evaluateColor(colorBrickL1, normalBrickL1, lightDirBrickL1, lightEnergyBrickL1, lod, clipPos.xyz, viewLobe);
            }
        } else {
            clipPos = (voxelToClipmapL2Mat * vec4(rayVoxelPos, 1.0f));
            clipPos = clipPos/clipPos.w;
            if(originL2.w != 0.0f && isNextToEachOther(ivec3(clipPos.xyz), ivec3(originL2.xyz))) {
                c= vec4(0.0f);
            } else {
                lod = lod - 2.0f;
                c = evaluateColor(colorBrickL2, normalBrickL2, lightDirBrickL2, lightEnergyBrickL2, lod, clipPos.xyz, viewLobe);
            }
        };
        color = alpha * color + (1.0f - alpha) * c.rgb;// * ((8.0f * 8.0f) / (len * len));
        alpha = alpha + (1.0f - alpha) * c.a;        
        rayVoxelPos += adjustedDir;
    }
    return color;
}
vec4 textureCasGridColorLod(vec3 voxelPos, float lod) {
    vec4 c;vec4 clipPos;
    if(lod < 1.0f) {
        clipPos = (voxelToClipmapL0Mat * vec4(voxelPos, 1.0f));
        c = texelFetch(colorBrickL0, ivec3(clipPos.xyz), int(lod));
    } else if(lod < 2.0f) {
        clipPos = (voxelToClipmapL1Mat * vec4(voxelPos, 1.0f));
        c = texelFetch(colorBrickL1, ivec3(clipPos.xyz), int(lod - 1.0f));
    } else {
        clipPos = (voxelToClipmapL2Mat * vec4(voxelPos, 1.0f));
        c = texelFetch(colorBrickL2, ivec3(clipPos.xyz), int(lod - 2.0f));

    }
    return c;
}
void voxelTest() {
    vec3 voxel1 = vec3(0.0f, 28.0f, 428.0f);
    int level1 = findMinLevel(voxel1);
    vec4 c = textureCasGridColorLod(voxel1, float(level1));
    logFragment(vec4(voxel1, c.a),  (voxelToClipmapL2Mat * vec4(voxel1, 1.0f)), uint(level1), uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);

    vec3 voxel2 = vec3(6.0f, 28.0f, 428.0f);
    int level2 = findMinLevel(voxel2);
    c = textureCasGridColorLod(voxel2, float(level2));
    logFragment(vec4(voxel2, c.a), (voxelToClipmapL2Mat * vec4(voxel2, 1.0f)), uint(level2), uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);

    for(int i = 0; i < 60; i+=2) {
        voxel2 = vec3(12.0f + float(i), 27.0f, 446.0f);
        level2 = findMinLevel(voxel2);
        c = textureCasGridColorLod(voxel2, float(level2));
        logFragment(vec4(voxel2, c.a), (voxelToClipmapL2Mat * vec4(voxel2, 1.0f)), uint(level2), uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
    }

}
// origin & dir in world space
// vec3 diffuseConeTraceTest() {
//     vec3 origin,dir; float angle=70.0f;
//     if(!isWithinBoundary(origin)) {
//         return vec3(0.0);
//     }
//     float alpha = 0.0f;
//     int level = findMinLevel(origin);
//     vec3 adjustedDir = pow(2, level) * dir; // lengthen dir when traversing through larger grid dim
//     vec3 rayVoxelPos = origin + adjustedDir*4.0f; //(set initial point further)
//     float lod; vec4 clipPos;

//     float cosPhi = cos(radians(angle));
//     GaussianLobe viewLobe;
//     viewLobe.amplitude = vec3(1.0f);
//     viewLobe.axis = -dir;
//     viewLobe.sharpness = 1.0f/(cosPhi * cosPhi);
//     vec3 color = vec3(0.0f);
//     vec4 c;
//     int i = 0;
//         float len = length(rayVoxelPos - origin);
//         lod = evaluateLOD(angle/2.0f, len);
//     while(alpha < 1.0f && isWithinBoundary(rayVoxelPos) && i < 32) {
//         i++;
//         if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
//             logFragment(vec4(dir, alpha), vec4(rayVoxelPos, lod), uint(findMinLevel(rayVoxelPos)), uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), uint(i));
//         }
//         //adjustedDir = pow(2, lod) * dir;
//         if(lod < 1.0f) {
//             clipPos = (voxelToClipmapL0Mat * vec4(rayVoxelPos, 1.0f));
//             clipPos = clipPos/clipPos.w / 128.0f;
//             c = evaluateColor(colorBrickL0, normalBrickL0, lightDirBrickL0, lightEnergyBrickL0, lod, clipPos.xyz, viewLobe);
//         } else if(lod < 2.0f) {
//             clipPos = (voxelToClipmapL1Mat * vec4(rayVoxelPos, 1.0f));
//             clipPos = clipPos/clipPos.w / 128.0f;
//             lod = lod - 1.0f;
//             c = evaluateColor(colorBrickL1, normalBrickL1, lightDirBrickL1, lightEnergyBrickL1, lod, clipPos.xyz, viewLobe);
//         } else {
//             clipPos = (voxelToClipmapL2Mat * vec4(rayVoxelPos, 1.0f));
//             clipPos = clipPos/clipPos.w / 128.0f;
//             lod = lod - 2.0f;
//             c = evaluateColor(colorBrickL2, normalBrickL2, lightDirBrickL2, lightEnergyBrickL2, lod, clipPos.xyz, viewLobe);
//         }
//         color = alpha * color + (1.0f - alpha) * c.rgb ;/// (len * len);
//         alpha = alpha + (1.0f - alpha) * c.a;        
//         rayVoxelPos += adjustedDir;
//     }
//     return color;
// }

vec3 findOrthoVector(vec3 v) {
    vec3 u = cross(v, vec3(1, 0, 0));
    if(abs(dot(u, v)) == 1.0f) {
        u = cross(v, vec3(0, 1, 0));
    }
    return normalize(u);
}

const float voxelDim = 511.0f;
void main() 
{   
    // if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
    //     voxelTest();
    // }
    ivec2 size = textureSize(gbufferWorldPosition, 0);
    ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
    
    if(xy.x < size.x && xy.y < size.y) {
        vec4 gbPos = texelFetch(gbufferWorldPosition, xy, 0);
        vec4 gbNormal = texelFetch(gbufferNormal, xy, 0);
        vec4 gbColor = texelFetch(gbufferAlbedo, xy, 0);
        float gbSpec = texelFetch(gbufferSpec, xy, 0).r;
        vec3 pos = (WorldToVoxelMat * gbPos).xyz;
        int level = findMinLevel(pos);
        originL0 = vec4(0.0f);
        originL1 = vec4(0.0f);
        originL2 = floor(voxelToClipmapL2Mat * vec4(pos, 1.0f));
        if(level < 2) {
            originL1 = floor(voxelToClipmapL1Mat * vec4(pos, 1.0f));
        }
        if(level < 1) {
            originL0 = floor(voxelToClipmapL0Mat * vec4(pos, 1.0f));
        }
        // 4x 60 from normal + 1 at normal;
        normal = normalize(gbNormal.xyz * 2.0f - 1.0f);
        vec3 orthoX = findOrthoVector(normal);
        vec3 orthoY = normalize(cross(normal, orthoX));
        float diffuseAngle = 60.0f;
        if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
            logFragment(WorldToVoxelMat * camPosition, camPosition, 0, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
            logFragment(vec4(pos, 1.0f), vec4(normal, 1.0f), 0, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
            logFragment(vec4(orthoX, 1.0f), vec4(orthoY, 1.0f), 0, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
            logFragment(vec4(normalize(mix(normal, orthoX, 0.6)), 1.0f), vec4(normalize(mix(normal, -orthoX, 0.6)), 1.0f), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
            logFragment(vec4(normalize(mix(normal, orthoY, 0.6)), 1.0f), vec4(normalize(mix(normal, -orthoY, 0.6)), 1.0f), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
            logFragment(vec4(0.0f), vec4(0.0f), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
        }
        vec3 diffuseColor = diffuseConeTrace(pos, normal, diffuseAngle);
        if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
            logFragment(vec4(0.0f), vec4(diffuseColor,0.0f), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
        }
        vec3 cone1 = normalize(mix(normal, orthoX, 0.4));
        diffuseColor += diffuseConeTrace(pos, cone1, diffuseAngle) * dot(normal, cone1);
        if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
            logFragment(vec4(0.0f), vec4(diffuseColor,0.0f), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
        }
        vec3 cone2 = normalize(mix(normal, -orthoX, 0.4));
        diffuseColor += diffuseConeTrace(pos, cone2, diffuseAngle) * dot(normal, cone2);
        if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
            logFragment(vec4(0.0f), vec4(diffuseColor,0.0f), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
        }
        vec3 cone3 = normalize(mix(normal, orthoY, 0.4));
        diffuseColor += diffuseConeTrace(pos, cone3, diffuseAngle) * dot(normal, cone3);
        if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
            logFragment(vec4(0.0f), vec4(diffuseColor,0.0f), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
        }
        vec3 cone4 = normalize(mix(normal, -orthoY, 0.4));
        diffuseColor += diffuseConeTrace(pos, cone4, diffuseAngle) * dot(normal, cone4);
        if(gl_GlobalInvocationID.x < 1 && gl_GlobalInvocationID.y < 1) {
            logFragment(vec4(0.0f), vec4(diffuseColor,0.0f), 1, uint(gl_GlobalInvocationID.x), uint(gl_GlobalInvocationID.y), 0);
        }
        vec3 view  = normalize(pos - camPosition.xyz);    
        vec3 specularColor = vec3(0.0f);
        diffuseColor /= PI;
        /*if(shininess > 0.0f) {
            specularColor = specularConeTrace(pos, reflect(view, normal), shininess);
        }*/
        imageStore(indirectAlbedo, xy, vec4(gbColor.rgb * (diffuseColor + specularColor), 1.0f));
    }
}