#version 450
#extension GL_ARB_shader_atomic_counter_ops : require

layout (local_size_x = 512) in;
layout(binding = 0) uniform atomic_uint fragListPtr;
//initlized at 1
layout(binding = 1) uniform atomic_uint nodePtr;
// initlized at 1
layout(binding = 2) uniform atomic_uint modelBrickPtr;
layout(binding = 3) uniform atomic_uint leafNodePtr;
layout(binding = 7) uniform atomic_uint logPtr;

struct FragmentStruct {
    vec4 position;
    vec4 color;
    vec4 normal;
};

layout(binding = 0) buffer FragmentListBlock {
    FragmentStruct frag[];
};

layout(binding = 1) buffer FragmentListBlock2 {
    FragmentStruct frag2[];
}; 

struct NodeStruct {
    uint parentPtr;
    uint selfPtr;
    uint childPtr;
    uint modelBrickPtr;
    uint lightBrickPtr;
};

layout(binding = 2) volatile buffer NodeBlock {
    NodeStruct node[];
};

layout(binding = 3) buffer ArrayBlock {
    uint leafList[];
};

struct LogStruct {
    vec4 position;
    vec4 color;
    uint nodeIndex;
    uint brickPtr;
    uint index1;
    uint index2;
};

layout(binding = 7) volatile buffer LogBlock {
    LogStruct logList[];
};

layout(binding = 0, r32ui) coherent uniform uimage3D rgColorBrick;
layout(binding = 1, r32ui) coherent uniform uimage3D baColorBrick;
layout(binding = 2, r32ui) coherent uniform uimage3D xyNormalBrick;
layout(binding = 3, r32ui) coherent uniform uimage3D zwNormalBrick;
layout(binding = 7, r32ui) uniform uimage3D fragmentCounter;

uniform uint noOfFragments;
uniform uint maxNoOfLogs;

uniform uint ISPROCESS = 0 - 1;
uniform uint LEAFHOST = 0 - 2;

void deferFragment() {
    uint index = atomicCounterIncrement(fragListPtr);
    frag2[index] = frag[gl_GlobalInvocationID.x];
}

void logFragment(vec4 pos, vec4 color, uint nodeIndex, uint brickPtr, uint index1, uint index2) {
    uint index = atomicCounterIncrement(logPtr);
    if(index < maxNoOfLogs) {        
        logList[index].position = pos;
        logList[index].color = color;
        logList[index].nodeIndex = nodeIndex;
        logList[index].brickPtr = brickPtr;
        logList[index].index1 = index1;
        logList[index].index2 = index2;
    } else {
        atomicCounterDecrement(logPtr);
    }
}

uint getPtrOffset(ivec3 frameOffset) {
    return min(frameOffset.x, 1) * 1 
    + min(frameOffset.y, 1) * 2 + min(frameOffset.z, 1) * 4;
}

uniform float levels[10] = float[10](0.001953125f, 0.00390625f, 0.0078125f,
                                0.015625f, 0.03125f, 0.0625f,
                                0.125f, 0.25f, 0.5f, 1.0f);

ivec3[10] computeLevelOffset() {
    ivec3 frameOffset = ivec3(0);
    ivec3 prevFrameOffset = ivec3(0);
    ivec3 levelOffsets[10];
    vec3 position = vec3(frag[gl_GlobalInvocationID.x].position);
    for(int i = 0; i < 10; i++) {
        prevFrameOffset = frameOffset * 2;
        frameOffset = ivec3(position * levels[i]);
        levelOffsets[i] = frameOffset - prevFrameOffset;
    }
    return levelOffsets;
}

uint enterNode(uint nodeIndex, uint offset) {
    uint childIndex = atomicCompSwap(node[nodeIndex].childPtr, 0, ISPROCESS);
    if(childIndex == 0) {
        childIndex = atomicCounterAddARB(nodePtr, 8);
        for(int i = 0; i < 8; i++) {
            node[childIndex + i].parentPtr = nodeIndex;
            node[childIndex + i].selfPtr = childIndex + i;
        }
        atomicCompSwap(node[nodeIndex].childPtr, ISPROCESS, childIndex);
        return childIndex + offset;
    } else if(childIndex == ISPROCESS) {
        deferFragment();
        return ISPROCESS;
    } else {
        return childIndex + offset;
    }
}
// leaf host node host 2x2 voxels
uint setupLeafHost(uint leafIndex) {
    uint leafState = atomicCompSwap(node[leafIndex].childPtr, 0, ISPROCESS);
    if(leafState == 0) {
        node[leafIndex].modelBrickPtr = atomicCounterIncrement(modelBrickPtr);
        uint index = atomicCounterIncrement(leafNodePtr);
        leafList[index] = leafIndex;
        atomicCompSwap(node[leafIndex].childPtr, ISPROCESS, LEAFHOST);
    } else if(leafState == ISPROCESS){
        deferFragment();
        return ISPROCESS;
    }
    
    return leafIndex;
}

uint convVec2ToRG16( vec2 val) {
return  ( uint( val .y ) &0x0000FFFF) <<16U | ( uint( val .x ) &0x0000FFFF);
}

vec2 convRG16ToVec2( uint val) {  
  return  vec2 ( float(val & 0x0000FFFF), float((val & 0xFFFF0000) >>16U));
}

uniform int lowestLevel = 9;
void main() {
    //frag position in 0 to 512 range
    if(gl_GlobalInvocationID.x < noOfFragments) {
        ivec3 levelOffsets[10] = computeLevelOffset();

        uint nodeIndex = 0;
        // start in root node
        int currentLevel = 0;

        while(currentLevel < lowestLevel - 1) {
            // move to next node  
            currentLevel++;
            nodeIndex = enterNode(nodeIndex, getPtrOffset(levelOffsets[currentLevel]));
            if(nodeIndex == ISPROCESS){
                return;
            }
        }
        nodeIndex = setupLeafHost(nodeIndex);
        if(nodeIndex == ISPROCESS){
            return;
        }

        memoryBarrier();
        uint brickPtr = node[nodeIndex].modelBrickPtr;
        uint bx = (brickPtr & 0x1FF) * 2;
        uint by = (brickPtr >> 9) * 2;
        ivec3 innerFrameOffset = levelOffsets[lowestLevel];
        ivec3 texturePos = ivec3(bx + innerFrameOffset.x, by + innerFrameOffset.y, innerFrameOffset.z);  
        FragmentStruct f = frag[gl_GlobalInvocationID.x];
        uint rg = imageAtomicAdd(rgColorBrick, texturePos, convVec2ToRG16(f.color.rg * 255.0f));
        uint ba = imageAtomicAdd(baColorBrick, texturePos, convVec2ToRG16(f.color.ba * 255.0f));
        uint xy = imageAtomicAdd(xyNormalBrick, texturePos, convVec2ToRG16(f.normal.xy * 255.0f));
        uint zw = imageAtomicAdd(zwNormalBrick, texturePos, convVec2ToRG16(f.normal.zw * 255.0f));
        uint count = imageAtomicAdd(fragmentCounter, texturePos, 1);
    }
    
}