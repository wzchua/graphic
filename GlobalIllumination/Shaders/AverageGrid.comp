#version 450
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(binding = 7, std140) uniform LogUniformBlock {
    uint maxNoOfLogs;
};
layout(binding = 1) coherent buffer CounterBlock {
    uint fragmentCounter;
    uint logCounter;
};
struct LogStruct {
    vec4 position;
    vec4 color;
    uint nodeIndex;
    uint brickPtr;
    uint index1;
    uint index2;
};

layout(binding = 7) volatile buffer LogBlock {
    LogStruct logList[];
};

layout(binding = 0, r32ui) uniform uimage3D rgColorBrick;
layout(binding = 1, r32ui) uniform uimage3D baColorBrick;
layout(binding = 2, r32ui) uniform uimage3D xyNormalBrick;
layout(binding = 3, r32ui) uniform uimage3D zwNormalBrick;
layout(binding = 4, RGBA8) uniform image3D colorBrick;
layout(binding = 5, RGBA8) uniform image3D normalBrick;
layout(binding = 7, r32ui) uniform uimage3D fragmentImageCounter;

void logFragment(vec4 pos, vec4 color, uint nodeIndex, uint brickPtr, uint index1, uint index2) {
    uint index = atomicAdd(logCounter, 1);
    if(index < maxNoOfLogs) {        
        logList[index].position = pos;
        logList[index].color = color;
        logList[index].nodeIndex = nodeIndex;
        logList[index].brickPtr = brickPtr;
        logList[index].index1 = index1;
        logList[index].index2 = index2;
    } else {
        atomicAdd(logCounter, uint(-1));
    }
}

uint convVec2ToRG16( vec2 val) {
    val = val * 255.0;
return  ( uint( val .y ) &0x0000FFFF) <<16U | ( uint( val .x ) &0x0000FFFF);
}

vec2 convRG16ToVec2( uint val) {  
  return  vec2 ( float(val & 0x0000FFFF), float((val & 0xFFFF0000) >>16U)) /255.0;
}
void main() {
    ivec3 voxelPos = ivec3(gl_GlobalInvocationID.xyz);
  if(voxelPos.x < 512 && voxelPos.y < 512 && voxelPos.z < 512 ) {
        float count = float(imageLoad(fragmentImageCounter, voxelPos).r);
        if(count != 0) {
            vec2 rg = convRG16ToVec2(imageLoad(rgColorBrick, voxelPos).r);
            vec2 ba = convRG16ToVec2(imageLoad(baColorBrick, voxelPos).r);
            vec4 color = vec4(rg, ba);
            
            vec4 avgColor = (color/count); 
            imageStore(colorBrick, voxelPos, avgColor);

            vec2 normalxy = convRG16ToVec2(imageLoad(xyNormalBrick, voxelPos).r);
            vec2 normalzw = convRG16ToVec2(imageLoad(zwNormalBrick, voxelPos).r);
            vec4 normal = vec4(normalxy, normalzw);

            vec4 avgNormal = normalize(normal/count);
            imageStore(normalBrick, voxelPos, avgNormal);    
            //logFragment(avgNormal, avgColor, 0, 0, 0, 0);  
        }
    }
}