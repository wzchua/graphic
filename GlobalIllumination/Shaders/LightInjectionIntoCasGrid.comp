#version 450
layout (local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgb10_a2) uniform sampler2D voxelPositionMap;
layout(binding = 1, rgb10_a2) uniform sampler2D worldNormalMap;

layout(binding = 4, std140) uniform VoxelizeCascadedBlock {
    mat4 voxelToClipmapL0Mat;
    mat4 voxelToClipmapL1Mat;
    mat4 voxelToClipmapL2Mat;
    vec4 level0min;
    vec4 level0max;
    vec4 level1min;
    vec4 level1max;
    vec4 level2min;
    vec4 level2max;
};



layout(binding = 0, r32ui) uniform coherent volatile uimage3D lightDirGridL0;
layout(binding = 1, r32ui) uniform coherent volatile uimage3D lightEnergyGridL0;
layout(binding = 2, r32ui) uniform coherent volatile uimage3D lightDirGridL1;
layout(binding = 3, r32ui) uniform coherent volatile uimage3D lightEnergyGridL1;
layout(binding = 4, r32ui) uniform coherent volatile uimage3D lightDirGridL2;
layout(binding = 5, r32ui) uniform coherent volatile uimage3D lightEnergyGridL2;


// includes -127.0f to 127.0f
vec4 convXYZWToVec4( uint val) {
    vec3 xyz = vec3(float (( val &0x000000FF)) , float (( val &0x0000FF00) >>8U) , float (( val &0x00FF0000) >>16U));
    xyz = xyz - 128.0f;
    return vec4 (  xyz, float (( val &0xFF000000) >>24U) );
}
vec4 convRGBA8ToVec4( uint val) {
    return vec4 ( float (( val &0x000000FF)) , float (( val &0x0000FF00) >>8U) , float (( val &0x00FF0000) >>16U) , float (( val &0xFF000000) >>24U) );
}
uint convVec4ToXYZW( vec4 val) {
    val.xyz = (val.xyz + 128.0f);
    return ( uint ( val.w) &0x000000FF) <<24U | ( uint( val.z) &0x000000FF) <<16U | ( uint( val.y ) &0x000000FF) <<8U | ( uint( val.x) &0x000000FF);
}
void imageAtomicXYZWAvg( layout ( r32ui ) coherent volatile uimage3D imgUI , ivec3 coords , vec4 val ) {
    val.rgb *= 127.0f;
    uint newVal = convVec4ToXYZW( val );
    uint prevStoredVal = 0; uint curStoredVal;
    // Loop as long as destination value gets changed by other threads
    while ( ( curStoredVal = imageAtomicCompSwap( imgUI , coords , prevStoredVal , newVal )) != prevStoredVal) {
        prevStoredVal = curStoredVal;
        vec4 rval = convXYZWToVec4( curStoredVal);
        if(rval.w >= 255.0f) {            
            break;
        }
        rval.xyz =( rval.xyz * rval.w) ; // Denormalize
        vec4 curValF = rval + val; // Add new value        
        curValF.xyz /=( curValF.w); // Renormalize
        if(rval.w == 1.0f) {
            logFragment(vec4(length(curValF.xyz), length(val.xyz), length(rval.xyz / rval.w), length(2 * unpackUnorm4x8(curStoredVal) - 1.0f)), 2 * unpackUnorm4x8(curStoredVal) - 1.0f, uint(gl_FragCoord.x), uint(gl_FragCoord.y), 0, 0);
        }
        newVal = convVec4ToXYZW( curValF );
    }
}


void computeLightValues(in vec3 voxelPos, in vec3 voxelLightPos, out vec3 lightDir, out uint recievedEnergy) {
  vec3 lightDisplacement = voxelLightPos - voxelPos;
  lightDir = normalize(lightDisplacement);
  float dist = length(lightDisplacement);
  float distSq = dist * dist;
  //light energy & direction
  recievedEnergy = uint(float(rad) / (distSq * dot(lightDir, normalize(wcNormal))));
}

void main() {
  ivec2 size = textureSize(worldPositionMap, 0);
  ivec2 xy = gl_GlobalInvocationID.xy;
  if(xy.x < size.x && xy.y < size.y) {
    vec3 voxelLightPos = (WorldToVoxelMat * vec4(LightPosition.xyz, 1.0f)).xyz;
    vec3 voxelPos = texelFetch(voxelPositionMap, xy, 0).xyz * voxelDim;
    vec3 lightDir; uint recievedEnergy;vec4 clipPos;
    computeLightValues(voxelPos, voxelLightPos, lightDir, recievedEnergy);
    
    clipPos = voxelToClipmapL0Mat * voxelPos;
    imageAtomicXYZWAvg(lightDirGridL0, ivec3(clipPos.xyz), vec4(lightDir, 1.0f));
    imageAtomicAdd(lightEnergyGridL0, pos, recievedEnergy);

    ivec2 upperLevelxy = xy/2;
    if(xy - 2 * upperLevelxy == ivec2(0)) {
      voxelPos = texelFetch(voxelPositionMap, upperLevelxy, 1).xyz * voxelDim;;
      computeLightValues(vec3(voxelPos), voxelLightPos, lightDir, recievedEnergy);

      clipPos = voxelToClipmapL1Mat * voxelPos;
      imageAtomicXYZWAvg(lightDirGridL1, ivec3(clipPos.xyz), vec4(lightDir, 1.0f));
      imageAtomicAdd(lightEnergyGridL1, pos, recievedEnergy);
    }
    upperLevelxy = xy/4;
    if(xy - 4 * upperLevelxy == ivec2(0)) {
      voxelPos = texelFetch(voxelPositionMap, upperLevelxy, 2).xyz * voxelDim;;
      computeLightValues(vec3(voxelPos), voxelLightPos, lightDir, recievedEnergy);

      clipPos = voxelToClipmapL2Mat * voxelPos;
      imageAtomicXYZWAvg(lightDirGridL2, ivec3(clipPos.xyz), vec4(lightDir, 1.0f));
      imageAtomicAdd(lightEnergyGridL2, pos, recievedEnergy);
    }
  }
}