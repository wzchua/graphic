layout(binding = 0) uniform sampler2D voxelPositionMap;
layout(binding = 1) uniform sampler2D worldNormalMap;

layout(binding = 0, r32ui) uniform coherent volatile uimage3D lightDirGridL0;
layout(binding = 1, r32ui) uniform coherent volatile uimage3D lightEnergyGridL0;
layout(binding = 2, r32ui) uniform coherent volatile uimage3D lightDirGridL1;
layout(binding = 3, r32ui) uniform coherent volatile uimage3D lightEnergyGridL1;
layout(binding = 4, r32ui) uniform coherent volatile uimage3D lightDirGridL2;
layout(binding = 5, r32ui) uniform coherent volatile uimage3D lightEnergyGridL2;

const float voxelDim = 511.0f;

// includes -127.0f to 127.0f
vec4 convXYZWToVec4( uint val) {
    vec3 xyz = vec3(float (( val &0x000000FF)) , float (( val &0x0000FF00) >>8U) , float (( val &0x00FF0000) >>16U));
    xyz = xyz - 128.0f;
    return vec4 (  xyz, float (( val &0xFF000000) >>24U) );
}
uint convVec4ToXYZW( vec4 val) {
    val.xyz = (val.xyz + 128.0f);
    return ( uint ( val.w) &0x000000FF) <<24U | ( uint( val.z) &0x000000FF) <<16U | ( uint( val.y ) &0x000000FF) <<8U | ( uint( val.x) &0x000000FF);
}
bool imageAtomicXYZWAvg( layout ( r32ui ) coherent volatile uimage3D imgUI , ivec3 coords , vec4 val ) {
    val.rgb *= 127.0f;
    uint newVal = convVec4ToXYZW( val );
    uint prevStoredVal = 0; uint curStoredVal;
    // Loop as long as destination value gets changed by other threads
    while ( ( curStoredVal = imageAtomicCompSwap( imgUI , coords , prevStoredVal , newVal )) != prevStoredVal) {
        prevStoredVal = curStoredVal;
        vec4 rval = convXYZWToVec4( curStoredVal);
        if(rval.w >= 255.0f) {          
            //logFragment(vec4(coords, 0.0f), vec4(gl_GlobalInvocationID.xy, 0.0f, 1.0f), 0, 0, 0, 0);
            return false;
        }
        rval.xyz =( rval.xyz * rval.w) ; // Denormalize
        vec4 curValF = rval + val; // Add new value        
        curValF.xyz /=( curValF.w); // Renormalize
        
        newVal = convVec4ToXYZW( curValF );
    }
    return true;
}

uint convVec4ToRGBA8( vec4 val) {
    return ( uint ( val.w) &0x000000FF) <<24U | ( uint( val.z) &0x000000FF) <<16U | ( uint( val.y ) &0x000000FF) <<8U | ( uint( val.x) &0x000000FF);
}
void imageAtomicAddFloat(layout ( r32ui ) coherent volatile uimage3D imgUI , ivec3 coords , float val ) {
    uint convertedVal = uint(val * 536870911.0f);
    imageAtomicAdd(imgUI, coords, convertedVal);
}


void computeLightValues(in vec3 voxelPos, in vec3 voxelLightPos, in vec3 normal, out vec3 lightDir, out vec4 recievedEnergy) {
  if(LightPosition.w == 0.0f) {
    lightDir = -normalize(LightPosition.xyz);
    recievedEnergy = 16.0f * LightPower / (abs(dot(lightDir, normalize(normal))));
  } else {
    vec3 lightDisplacement = voxelLightPos - voxelPos;
    lightDir = normalize(lightDisplacement);
    float dist = length(lightDisplacement)/8.0f;
    float distSq = dist * dist;
    //light energy & direction
    recievedEnergy = LightPower / (distSq * abs(dot(lightDir, normalize(normal))));
  }
}

bool isWithinBoundaries(int level, vec3 voxelPos) {
    if(level == 0) {
        return voxelPos.x >= level0min.x && voxelPos.x < level0max.x
        && voxelPos.y >= level0min.y && voxelPos.y < level0max.y
        && voxelPos.z >= level0min.z && voxelPos.z < level0max.z;
    } else if(level == 1) {
        return voxelPos.x >= level1min.x && voxelPos.x < level1max.x
        && voxelPos.y >= level1min.y && voxelPos.y < level1max.y
        && voxelPos.z >= level1min.z && voxelPos.z < level1max.z;
    } else {
        return voxelPos.x >= level2min.x && voxelPos.x < level2max.x
        && voxelPos.y >= level2min.y && voxelPos.y < level2max.y
        && voxelPos.z >= level2min.z && voxelPos.z < level2max.z;
    }
}

void main() {
    ivec2 size = textureSize(voxelPositionMap, 0);
    ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
    if(xy.x < size.x && xy.y < size.y) {
        vec3 voxelLightPos = (WorldToVoxelMat * vec4(LightPosition.xyz, 1.0f)).xyz;
        vec4 voxelPosRead = texelFetch(voxelPositionMap, xy, 0);
        vec3 lightDir; vec4 recievedEnergy; vec4 clipPos;
        vec3 voxelPos;
        vec3 wcNormal;         
        voxelPos = voxelPosRead.xyz * voxelDim;
        if(voxelPosRead.w != 0.0f && isWithinBoundaries(0, voxelPos)) {   
            wcNormal = texelFetch(worldNormalMap, xy, 0).xyz * 2.0f - 1.0f;
            computeLightValues(voxelPos, voxelLightPos, wcNormal, lightDir, recievedEnergy);
            clipPos = voxelToClipmapL0Mat * vec4(voxelPos, 1.0f);//check if within grid
            // if(gl_GlobalInvocationID.x >= 512 && gl_GlobalInvocationID.x < 514 && gl_GlobalInvocationID.y >=512 && gl_GlobalInvocationID.y < 514 ) {
            //     logFragment(vec4(voxelPos.xyz,recievedEnergy.r), clipPos, (isWithinBoundaries(0, voxelPos)) ? 1:0, uint(xy.x), uint(xy.y), 3);
            // }
            if(imageAtomicXYZWAvg(lightDirGridL0, ivec3(clipPos.xyz), vec4(lightDir, 1.0f))) {
                imageAtomicAddFloat(lightEnergyGridL0, ivec3(clipPos.xyz), recievedEnergy.r);
            }
        }
        ivec2 upperLevelxy = xy/2;
        if(xy - 2 * upperLevelxy == ivec2(0)) {
            voxelPosRead = texelFetch(voxelPositionMap, upperLevelxy, 1);
            voxelPos = voxelPosRead.xyz * voxelDim;
            if(voxelPosRead.w != 0.0f && isWithinBoundaries(1, voxelPos)) {  
                wcNormal = texelFetch(worldNormalMap, upperLevelxy, 1).xyz * 2.0f - 1.0f;
                computeLightValues(voxelPos, voxelLightPos, wcNormal, lightDir, recievedEnergy);
                clipPos = voxelToClipmapL1Mat * vec4(voxelPos, 1.0f);
                // if(gl_GlobalInvocationID.x == 512 && gl_GlobalInvocationID.y ==512) {
                //     logFragment(vec4(voxelPos.xyz,recievedEnergy.r), clipPos, (isWithinBoundaries(0, voxelPos)) ? 1:0, 4, 2, 3);
                // }

                if(imageAtomicXYZWAvg(lightDirGridL1, ivec3(clipPos.xyz), vec4(lightDir, 1.0f))) {
                    imageAtomicAddFloat(lightEnergyGridL1, ivec3(clipPos.xyz), recievedEnergy.r);
                }
            }
        }
        upperLevelxy = xy/4;
        if(xy - 4 * upperLevelxy == ivec2(0)) {
            voxelPosRead = texelFetch(voxelPositionMap, upperLevelxy, 2);
            voxelPos = voxelPosRead.xyz * voxelDim;
            if(voxelPosRead.w != 0.0f && isWithinBoundaries(2, voxelPos)) {  
                wcNormal = texelFetch(worldNormalMap, upperLevelxy, 2).xyz * 2.0f - 1.0f;
                computeLightValues(voxelPos, voxelLightPos, wcNormal, lightDir, recievedEnergy);

                clipPos = voxelToClipmapL2Mat * vec4(voxelPos, 1.0f);
                if(imageAtomicXYZWAvg(lightDirGridL2, ivec3(clipPos.xyz), vec4(lightDir, 1.0f))) {
                    imageAtomicAddFloat(lightEnergyGridL2, ivec3(clipPos.xyz), recievedEnergy.r);
                }
            }
        }
    }
}