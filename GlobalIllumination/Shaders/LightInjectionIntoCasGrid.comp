layout(binding = 0) uniform sampler2D voxelPositionMap;
layout(binding = 1) uniform sampler2D worldNormalMap;

layout(binding = 0, r32ui) uniform coherent volatile uimage3D lightDirGridL0;
layout(binding = 1, r32ui) uniform coherent volatile uimage3D lightEnergyGridL0;
layout(binding = 2, r32ui) uniform coherent volatile uimage3D lightDirGridL1;
layout(binding = 3, r32ui) uniform coherent volatile uimage3D lightEnergyGridL1;
layout(binding = 4, r32ui) uniform coherent volatile uimage3D lightDirGridL2;
layout(binding = 5, r32ui) uniform coherent volatile uimage3D lightEnergyGridL2;

const float voxelDim = 512.0f;

// includes -127.0f to 127.0f
vec4 convXYZWToVec4( uint val) {
    vec3 xyz = vec3(float (( val &0x000000FF)) , float (( val &0x0000FF00) >>8U) , float (( val &0x00FF0000) >>16U));
    xyz = xyz - 128.0f;
    return vec4 (  xyz, float (( val &0xFF000000) >>24U) );
}
uint convVec4ToXYZW( vec4 val) {
    val.xyz = (val.xyz + 128.0f);
    return ( uint ( val.w) &0x000000FF) <<24U | ( uint( val.z) &0x000000FF) <<16U | ( uint( val.y ) &0x000000FF) <<8U | ( uint( val.x) &0x000000FF);
}
bool imageAtomicXYZWAvg( layout ( r32ui ) coherent volatile uimage3D imgUI , ivec3 coords , vec4 val ) {
    val.rgb *= 127.0f;
    uint newVal = convVec4ToXYZW( val );
    uint prevStoredVal = 0; uint curStoredVal;
    // Loop as long as destination value gets changed by other threads
    while ( ( curStoredVal = imageAtomicCompSwap( imgUI , coords , prevStoredVal , newVal )) != prevStoredVal) {
        prevStoredVal = curStoredVal;
        vec4 rval = convXYZWToVec4( curStoredVal);
        if(rval.w >= 255.0f) {          
            //logFragment(vec4(coords, 0.0f), vec4(gl_GlobalInvocationID.xy, 0.0f, 1.0f), 0, 0, 0, 0);
            return false;
        }
        rval.xyz =( rval.xyz * rval.w) ; // Denormalize
        vec4 curValF = rval + val; // Add new value        
        curValF.xyz /=( curValF.w); // Renormalize
        
        newVal = convVec4ToXYZW( curValF );
    }
    return true;
}

uint convVec4ToRGBA8( vec4 val) {
    return ( uint ( val.w) &0x000000FF) <<24U | ( uint( val.z) &0x000000FF) <<16U | ( uint( val.y ) &0x000000FF) <<8U | ( uint( val.x) &0x000000FF);
}
void imageAtomicAddFloat(layout ( r32ui ) coherent volatile uimage3D imgUI , ivec3 coords , float val ) {
    uint convertedVal = uint(val * 536870911.0f);
    imageAtomicAdd(imgUI, coords, convertedVal);
}


void computeLightValues(in vec3 voxelPos, in vec3 voxelLightPos, in vec3 normal, out vec3 lightDir, out vec4 recievedEnergy) {
  vec3 lightDisplacement = voxelLightPos - voxelPos;
  lightDir = normalize(lightDisplacement);
  float dist = length(lightDisplacement)/8.0f;
  float distSq = dist * dist;
  //light energy & direction
  recievedEnergy = LightPower / (distSq * abs(dot(lightDir, normalize(normal))));
}

void main() {
    ivec2 size = textureSize(voxelPositionMap, 0);
    ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
    if(xy.x < size.x && xy.y < size.y) {
        vec3 voxelPos = texelFetch(voxelPositionMap, xy, 0).xyz * voxelDim;
        vec3 wcNormal = texelFetch(worldNormalMap, xy, 0).xyz * 2.0f - 1.0f;
        vec3 voxelLightPos = (WorldToVoxelMat * vec4(LightPosition.xyz, 1.0f)).xyz;
        vec3 lightDir; vec4 recievedEnergy; vec4 clipPos;
        computeLightValues(voxelPos, voxelLightPos, wcNormal, lightDir, recievedEnergy);

        clipPos = voxelToClipmapL0Mat * vec4(voxelPos, 1.0f);
        if(imageAtomicXYZWAvg(lightDirGridL0, ivec3(clipPos.xyz), vec4(lightDir, 1.0f))) {
            imageAtomicAddFloat(lightEnergyGridL0, ivec3(clipPos.xyz), recievedEnergy.r);
        }

        ivec2 upperLevelxy = xy/2;
        if(xy - 2 * upperLevelxy == ivec2(0)) {
            voxelPos = texelFetch(voxelPositionMap, upperLevelxy, 1).xyz * voxelDim;
            wcNormal = texelFetch(worldNormalMap, xy, 1).xyz * 2.0f - 1.0f;
            computeLightValues(voxelPos, voxelLightPos, wcNormal, lightDir, recievedEnergy);

            clipPos = voxelToClipmapL1Mat * vec4(voxelPos, 1.0f);
            if(imageAtomicXYZWAvg(lightDirGridL1, ivec3(clipPos.xyz), vec4(lightDir, 1.0f))) {
                imageAtomicAddFloat(lightEnergyGridL1, ivec3(clipPos.xyz), recievedEnergy.r);
            }
        }
        upperLevelxy = xy/4;
        if(xy - 4 * upperLevelxy == ivec2(0)) {
            voxelPos = texelFetch(voxelPositionMap, upperLevelxy, 2).xyz * voxelDim;
            wcNormal = texelFetch(worldNormalMap, xy, 2).xyz * 2.0f - 1.0f;
            computeLightValues(voxelPos, voxelLightPos, wcNormal, lightDir, recievedEnergy);

            clipPos = voxelToClipmapL2Mat * vec4(voxelPos, 1.0f);
            if(imageAtomicXYZWAvg(lightDirGridL2, ivec3(clipPos.xyz), vec4(lightDir, 1.0f))) {
                imageAtomicAddFloat(lightEnergyGridL2, ivec3(clipPos.xyz), recievedEnergy.r);
            }
        }
    }
}