layout(binding = 0) uniform sampler2D voxelPositionMap;
layout(binding = 1) uniform sampler2D worldNormalMap;

const float voxelDim = 511.0f;


// includes -127.0f to 127.0f
vec4 convXYZWToVec4( uint val) {
    vec3 xyz = unpackSnorm4x8(val).xyz;
    return vec4 (  xyz, float (( val &0xFF000000) >>24U) );
}
uint convVec4ToXYZW( vec4 val) {
    uint iVal = packSnorm4x8(val);
    iVal = (iVal & 0x00FFFFFF) | ((uint ( val.w) &0x000000FF) <<24U);
    return iVal;
}
bool atomicNormalAvg( uint index , vec4 val) {
    uint newVal = convVec4ToXYZW( val );
    uint prevStoredVal = 0; uint curStoredVal;
    // Loop as long as destination value gets changed by other threads
    while ( ( curStoredVal = atomicCompSwap( nodeBrick[index].lightDirection , prevStoredVal , newVal )) != prevStoredVal) {
        prevStoredVal = curStoredVal;
        vec4 rval = convXYZWToVec4( curStoredVal);
        if(rval.w >= 255.0f) {          
            //logFragment(vec4(coords, 0.0f), rval, 0, 0, 0, 0);
            return false;
        }
        rval.xyz =( rval.xyz * rval.w) ; // Denormalize
        vec4 curValF = rval + val; // Add new value
        curValF.xyz /=( curValF.w); // Renormalize
        newVal = convVec4ToXYZW( curValF );
    }
    return true;
}


void computeLightValues(in vec3 voxelPos, in vec3 voxelLightPos, in vec3 normal, out vec3 lightDir, out vec4 recievedEnergy) {
  if(LightPosition.w == 0.0f) {
    lightDir = -normalize(LightPosition.xyz);
    recievedEnergy =  8.0f *LightPower;
  } else {
    vec3 lightDisplacement = voxelLightPos - voxelPos;
    lightDir = normalize(lightDisplacement);
    float dist = length(lightDisplacement)/8.0f;
    float distSq = dist * dist;
    //light energy & direction
    recievedEnergy = LightPower;
  }
}
uniform uint INVALID = 0 - 1;
const float levels[10] = float[10](0.001953125f, 0.00390625f, 0.0078125f,
                                0.015625f, 0.03125f, 0.0625f,
                                0.125f, 0.25f, 0.5f, 1.0f);

const int leafLevel = 9;
uint getPtrOffset(ivec3 frameOffset) {
    return min(frameOffset.x, 1) * 1 
    + min(frameOffset.y, 1) * 2 + min(frameOffset.z, 1) * 4;
}
uint SearchOctree(vec3 pos) {
    uint nodeId = 0;
    vec3 prevSamplePos;
    vec3 samplePos = vec3(0.0f);
    vec3 refOffset;
    for(int i = 0; i < leafLevel; i++) {
        prevSamplePos = samplePos;
        samplePos = pos * levels[i];
        refOffset = samplePos - 2 * floor(prevSamplePos);
        uint child = node[nodeId].childPtr;
        uint childOffset = getPtrOffset(ivec3(refOffset));
        if(child == 0 || ((node[nodeId].childBit >> childOffset) & 1) == 0) {
            nodeId = INVALID;
            return nodeId;
        }
        nodeId = child + childOffset;
    }
    prevSamplePos = samplePos;
    samplePos = pos * levels[leafLevel];
    refOffset = samplePos - 2 * floor(prevSamplePos);
    uint leafOffset = getPtrOffset(ivec3(refOffset));
    uint childBit = node[nodeId].childBit;
    if(((childBit >> leafOffset) & 1) == 0) {
        nodeId = INVALID;
    }
    return nodeId;
}
void main() {
    ivec2 size = textureSize(voxelPositionMap, 0);
    ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
    if(xy.x < size.x && xy.y < size.y) {
        vec3 voxelLightPos = (WorldToVoxelMat * vec4(LightPosition.xyz, 1.0f)).xyz;
        vec4 voxelPosRead = texelFetch(voxelPositionMap, xy, 0);
        vec3 lightDir; vec4 recievedEnergy;
        vec3 voxelPos;
        vec3 wcNormal;         
        voxelPos = voxelPosRead.xyz * voxelDim;
        if(voxelPosRead.w != 0.0f) {
            wcNormal = texelFetch(worldNormalMap, xy, 0).xyz * 2.0f - 1.0f;
            computeLightValues(voxelPos, voxelLightPos, wcNormal, lightDir, recievedEnergy);
            uint nodeId = SearchOctree(floor(voxelPos));
            if(nodeId == INVALID) {
                //logFragment(vec4(voxelPos, 1.0f), vec4(0.0f), 0, 0, 0, 0);
            } else {                
                uint valueIndex = node[nodeId].valueIndex;
                if(atomicNormalAvg(valueIndex, vec4(lightDir, 1.0f))) {                    
                    uint convertedVal = uint(recievedEnergy.r * 8388607.0f);
                    atomicAdd(nodeBrick[valueIndex].lightEnergy, convertedVal);

                }
            }
        }
    }
}