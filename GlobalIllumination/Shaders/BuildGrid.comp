#version 450
#extension GL_ARB_shader_atomic_counter_ops : require

layout (local_size_x = 512) in;
layout(binding = 0) uniform atomic_uint voxelPtr;
layout(binding = 7) uniform atomic_uint logPtr;

struct FragmentStruct {
    vec4 position;
    vec4 color;
    vec4 normal;
};

layout(binding = 0) buffer FragmentListBlock {
    FragmentStruct frag[];
};

layout(binding = 1) buffer ArrayBlock {
    ivec4 voxelList[];
};

struct LogStruct {
    vec4 position;
    vec4 color;
    uint nodeIndex;
    uint brickPtr;
    uint index1;
    uint index2;
};

layout(binding = 7) volatile buffer LogBlock {
    LogStruct logList[];
};

layout(binding = 0, r32ui) coherent uniform uimage3D rgColorBrick;
layout(binding = 1, r32ui) coherent uniform uimage3D baColorBrick;
layout(binding = 2, r32ui) coherent uniform uimage3D xyNormalBrick;
layout(binding = 3, r32ui) coherent uniform uimage3D zwNormalBrick;
layout(binding = 7, r32ui) uniform uimage3D fragmentCounter;

uniform uint noOfFragments;
uniform uint maxNoOfLogs;

void logFragment(vec4 pos, vec4 color, uint nodeIndex, uint brickPtr, uint index1, uint index2) {
    uint index = atomicCounterIncrement(logPtr);
    if(index < maxNoOfLogs) {        
        logList[index].position = pos;
        logList[index].color = color;
        logList[index].nodeIndex = nodeIndex;
        logList[index].brickPtr = brickPtr;
        logList[index].index1 = index1;
        logList[index].index2 = index2;
    } else {
        atomicCounterDecrement(logPtr);
    }
}

uint convVec2ToRG16( vec2 val) {
return  ( uint( val .y ) &0x0000FFFF) <<16U | ( uint( val .x ) &0x0000FFFF);
}

vec2 convRG16ToVec2( uint val) {  
  return  vec2 ( float(val & 0x0000FFFF), float((val & 0xFFFF0000) >>16U));
}

void main() {
    //frag position in 0 to 512 range
    if(gl_GlobalInvocationID.x < noOfFragments) { 
        FragmentStruct f = frag[gl_GlobalInvocationID.x];
        
        ivec3 texturePos = ivec3(f.position.xyz); 
        uint rg = imageAtomicAdd(rgColorBrick, texturePos, convVec2ToRG16(f.color.rg * 255.0f));
        uint ba = imageAtomicAdd(baColorBrick, texturePos, convVec2ToRG16(f.color.ba * 255.0f));
        uint xy = imageAtomicAdd(xyNormalBrick, texturePos, convVec2ToRG16(f.normal.xy * 255.0f));
        uint zw = imageAtomicAdd(zwNormalBrick, texturePos, convVec2ToRG16(f.normal.zw * 255.0f));
        uint count = imageAtomicAdd(fragmentCounter, texturePos, 1);
        if(count == 0) {
            uint index = atomicCounterIncrement(voxelPtr);
            voxelList[index] = ivec4(texturePos, 1;
        }
    }
    
}