#version 450
layout (local_size_x = 512) in;

struct NodeStruct {
    uint parentPtr;
    uint childPtr;
    uint childBit;
    uint modelBrickPtr;
    uint lightBit;
    uint lightBrickPtr;
    uint xPositive;
    uint xNegative;
    uint yPositive;
    uint yNegative;
    uint zPositive;
    uint zNegative;
};

layout(binding = 1) coherent buffer CounterBlock {
    uint fragmentCounter;
    uint nodeCounter;
    uint brickCounter;
    uint leafCounter;
    uint logCounter;
    uint noOfFragments;
};
layout(binding = 2) coherent buffer NodeBlock {
    NodeStruct node[];
};
layout(binding = 3) coherent buffer ArrayBlock {
    uint leafList[];
};
layout(binding = 4) coherent buffer ArrayBlock {
    uint newLeafList[];
};

layout(binding = 4, RGBA8) uniform coherent volatile uimage3D colorBrick;
layout(binding = 5, r32ui) uniform coherent volatile uimage3D normalBrick;


ivec3 computeOffset(uint bx, uint by, int childIndex) {    
    return ivec3(bx + (i & childIndex), by + ((childIndex & 2) >> 1), (childIndex & 4) >> 2);
}

const uint LEAFHOST = 0 - 2;
// includes -1.0f to 1.0f
vec4 convXYZWToVec4( uint val) {
    vec3 xyz = vec3(float (( val &0x000000FF)) , float (( val &0x0000FF00) >>8U) , float (( val &0x00FF0000) >>16U));
    xyz = (xyz - 128.0f) / 127.0f;
    return vec4 (  xyz, float (( val &0xFF000000) >>24U) );
}
uint convVec4ToXYZW( vec4 val) {
    val.xyz = (val.xyz * 127.0f + 128.0f);
    return ( uint ( val.w) &0x000000FF) <<24U | ( uint( val.z) &0x000000FF) <<16U | ( uint( val.y ) &0x000000FF) <<8U | ( uint( val.x) &0x000000FF);
}
void main() {
    
  uint nodeListPtr = gl_GlobalInvocationID.x;
    if(nodeListPtr < leafCounter) {
        uint childPtr = leafList[nodeListPtr];
        NodeStruct child = node[childPtr];
        bool isLeaf = child.childPtr == LEAFHOST;
        uint parentPtr = child.parentPtr;      
        // collect child 2x2x2 into 1x1x1 value
        uint brickChildId = child.modelBrickPtr;
        uint leafChildBits = child.childBit;
        uint bx = (brickChildId & 0x1FF) * 2;
        uint by = (brickChildId >> 9) * 2;
        vec4 color = vec4(0.0f);
        vec4 normal = vec4(0.0f);
        uint count = 0;
        for(int i = 0; i < 8; i++) {
            uint hasChild = (childBits >> i) & 0x01;
            //check child bit
            if(hasChild == 1) {    
                count += 1;
                ivec3 pos = computeOffset(bx, by, i);
                vec4 cColor = imageLoad(colorBrick, pos);
                vec4 cNormal = convXYZWToVec4(imageLoad(normalBrick, pos).a);
                if(isLeaf) { //normalize leaf alpha (used as counter in previous stage)
                    cColor.a = 1.0f;
                    imageStore(colorBrick, pos, cColor);
                    cNormal.a = 1.0f;
                    imageStore(normalBrick, pos, convVec4ToXYZW(cNormal));
                }
                color += cColor;
                normal += cNormal;
            }
        }
        float countf = float(count);
        color = color / countf;
        normal = normal / countf;
        NodeStruct parent = node[parentPtr];
        uint childIndex = childPtr - parent.childPtr;
        uint parentChildBits = parent.childBit;
        uint unflaggedParentChildBits = 0x0FF & parentChildBits;
        uint flaggedParentChildBits = unflaggedParentChildBits | 0x100;
        uint atomicParentChildBit = atomicCompSwap(node[parentPtr].childBit, unflaggedParentChildBits, flaggedParentChildBits);
        if(atomicParentChildBit == unflaggedParentChildBits) {
            uint leafIndex = atomicAdd(leafCounter, 1);
            newLeafList[leafIndex] = parentPtr;
        }
        uint brickParentId = parent.modelBrickPtr;
        uint pbx = (brickParentId & 0x1FF) * 2;
        uint pby = (brickParentId >> 9) * 2;        
        ivec3 parentPos = computeOffset(pbx, pby, childIndex);
        imageStore(colorBrick, parentPos, color);
        imageStore(normalBrick, parentPos, convVec4ToXYZW(normal));
    }
}