#version 450
layout (local_size_x = 512) in;

struct NodeStruct {
    uint parentPtr;
    uint childPtr;
    uint childBit;
    uint modelBrickPtr;
    uint lightBit;
    uint lightBrickPtr;
    uint xPositive;
    uint xNegative;
    uint yPositive;
    uint yNegative;
    uint zPositive;
    uint zNegative;
};

layout(binding = 1) coherent buffer CounterBlock {
    uint fragmentCounter;
    uint nodeCounter;
    uint brickCounter;
    uint leafCounter;
    uint logCounter;
    uint noOfFragments;
};
layout(binding = 2) coherent buffer NodeBlock {
    NodeStruct node[];
};

layout(binding = 8, RGBA8) writeonly uniform image3D colorBrick;
layout(binding = 9, RGBA8) writeonly uniform image3D normalBrick;

layout(binding = 8, RGBA8) uniform sampler3D colorBrickSampler;
layout(binding = 9, RGBA8) uniform sampler3D normalBrickSampler;

layout(binding = 3) buffer ArrayBlock {
    uint leafList[];
};

ivec3 computeOffset(uint bx, uint by, int childIndex) {    
    return ivec3(bx + (i & childIndex), by + ((childIndex & 2) >> 1), (childIndex & 4) >> 2);
}

const uint LEAFHOST = 0 - 2;
void main() {
    
  uint nodeListPtr = gl_GlobalInvocationID.x;
    if(nodeListPtr < leafCounter) {
        uint childPtr = leafList[nodeListPtr];
        NodeStruct child = node[childPtr];
        bool isLeaf = child.childPtr == LEAFHOST;
        uint parentPtr = child.parentPtr;      
        // collect child 2x2x2 into 1x1x1 value
        uint brickChildId = child.modelBrickPtr;
        uint leafChildBits = child.childBit;
        uint bx = (brickChildId & 0x1FF) * 2;
        uint by = (brickChildId >> 9) * 2;
        vec4 color = vec4(0.0f);
        for(int i = 0; i < 8; i++) {
            uint hasChild = (childBits >> i) & 0x01;
            //check child bit
            if(hasChild == 1) {    
                ivec3 pos = computeOffset(bx, by, i);
                vec4 cColor = texelFetch(colorBrickSampler, pos, 0);
                if(isLeaf) { //normalize leaf alpha (used as counter in previous stage)
                    cColor.a = 1.0f;
                    imageStore(colorBrick, pos, cColor);
                }
                color += cColor;
            }
        }
        color = color / 8.0f;
        NodeStruct parent = node[parentPtr];
        uint childIndex = childPtr - parent.childPtr;
        uint brickParentId = parent.modelBrickPtr;
        uint pbx = (brickParentId & 0x1FF) * 2;
        uint pby = (brickParentId >> 9) * 2;        
        imageStore(colorBrick, computeOffset(pbx, pby, childIndex), color);
    }
}