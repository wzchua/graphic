#version 450
layout (local_size_x = 512) in;

struct NodeStruct {
    uint parentPtr;
    uint childPtr;
    uint childBit;
    uint modelBrickPtr;
    uint lightBit;
    uint lightBrickPtr;
    uint xPositive;
    uint xNegative;
    uint yPositive;
    uint yNegative;
    uint zPositive;
    uint zNegative;
};

layout(binding = 1) coherent buffer CounterBlock {
    uint fragmentCounter;
    uint nodeCounter;
    uint brickCounter;
    uint leafCounter;
    uint logCounter;
    uint noOfFragments;
};
layout(binding = 2) coherent buffer NodeBlock {
    NodeStruct node[];
};
layout(binding = 3) coherent buffer ArrayBlock {
    uint leafList[];
};
layout(binding = 4) coherent buffer ArrayBlock {
    uint newLeafList[];
};

layout(binding = 4, RGBA8) uniform coherent volatile uimage3D colorBrick;
layout(binding = 5, r32ui) uniform coherent volatile uimage3D normalBrick;


ivec3 computeOffset(uint bx, uint by, int childIndex) {    
    return ivec3(bx + (i & childIndex), by + ((childIndex & 2) >> 1), (childIndex & 4) >> 2);
}

//Referenced from: OpenGL Insight Chapter 22
vec4 convRGBA8ToVec4( uint val) {
    return vec4 ( float (( val &0x000000FF)) , float (( val &0x0000FF00) >>8U) , float (( val &0x00FF0000) >>16U) , float (( val &0xFF000000) >>24U) );
}
uint convVec4ToRGBA8( vec4 val) {
    return ( uint ( val.w) &0x000000FF) <<24U | ( uint( val.z) &0x000000FF) <<16U | ( uint( val.y ) &0x000000FF) <<8U | ( uint( val.x) &0x000000FF);
}
bool atomicColorAvg(uint index , vec4 val ) {
    val.rgb *=255.0f; // Optimise following calculations
    uint newVal = convVec4ToRGBA8( val );
    uint prevStoredVal = 0; uint curStoredVal;
    // Loop as long as destination value gets changed by other threads
    while ( ( curStoredVal = atomicCompSwap( nodeBrick[index].color , prevStoredVal , newVal )) != prevStoredVal) {
        prevStoredVal = curStoredVal;
        vec4 rval = convRGBA8ToVec4( curStoredVal);
        if(rval.w >= 255.0f) {          
            //logFragment(vec4(coords, 0.0f), rval, 0, 0, 0, 0);
            return false;
        }
        rval.xyz =( rval.xyz * rval.w) ; // Denormalize
        vec4 curValF = rval + val; // Add new value
        curValF.xyz /=( curValF.w); // Renormalize
        newVal = convVec4ToRGBA8( curValF );
    }
    return true;
}

// includes -127.0f to 127.0f
vec4 convXYZWToVec4( uint val) {
    vec3 xyz = unpackSnorm4x8(val).xyz;
    return vec4 (  xyz, float (( val &0xFF000000) >>24U) );
}
uint convVec4ToXYZW( vec4 val) {
    uint iVal = packSnorm4x8(val);
    iVal = (iVal & 0x00FFFFFF) | ((uint ( val.w) &0x000000FF) <<24U);
    return iVal;
}
bool atomicNormalAvg( uint index , vec4 val) {
    uint newVal = convVec4ToXYZW( val );
    uint prevStoredVal = 0; uint curStoredVal;
    // Loop as long as destination value gets changed by other threads
    while ( ( curStoredVal = atomicCompSwap( nodeBrick[index].normal , prevStoredVal , newVal )) != prevStoredVal) {
        prevStoredVal = curStoredVal;
        vec4 rval = convXYZWToVec4( curStoredVal);
        if(rval.w >= 255.0f) {          
            //logFragment(vec4(coords, 0.0f), rval, 0, 0, 0, 0);
            return false;
        }
        rval.xyz =( rval.xyz * rval.w) ; // Denormalize
        vec4 curValF = rval + val; // Add new value
        curValF.xyz /=( curValF.w); // Renormalize
        newVal = convVec4ToXYZW( curValF );
    }
    return true;
}
bool atomicLightDirAvg( uint index , vec4 val) {
    uint newVal = convVec4ToXYZW( val );
    uint prevStoredVal = 0; uint curStoredVal;
    // Loop as long as destination value gets changed by other threads
    while ( ( curStoredVal = atomicCompSwap( nodeBrick[index].lightDirection , prevStoredVal , newVal )) != prevStoredVal) {
        prevStoredVal = curStoredVal;
        vec4 rval = convXYZWToVec4( curStoredVal);
        if(rval.w >= 255.0f) {          
            //logFragment(vec4(coords, 0.0f), rval, 0, 0, 0, 0);
            return false;
        }
        rval.xyz =( rval.xyz * rval.w) ; // Denormalize
        vec4 curValF = rval + val; // Add new value
        curValF.xyz /=( curValF.w); // Renormalize
        newVal = convVec4ToXYZW( curValF );
    }
    return true;
}
void main() {
    
  uint nodeListPtr = gl_GlobalInvocationID.x;
    if(nodeListPtr < leafCounter) {
        uint childPtr = leafList[nodeListPtr];
        NodeStruct child = node[childPtr];

        uint parentPtr = child.parentPtr;      
        uint valueIndex = child.valueIndex;
        NodeValueStruct val = nodeBrick[valueIndex];
        vec4 c = convXYZWToVec4(val.color);
        c.a = 1.0f;
        val.color = convVec4ToXYZW(c);
        vec4 n = convXYZWToVec4(val.normal);
        n.w = 1.0f;
        val.normal = convVec4ToXYZW(n);
        vec4 d = convXYZWToVec4(val.lightDirection);
        d.w = 1.0f;
        val.lightDirection = convVec4ToXYZW(d);
        nodeBrick[valueIndex] = val;
        uint parentValueIndex = node[parentPtr].valueIndex;
        atomicColorAvg(parentValueIndex, c);
        atomicNormalAvg(parentValueIndex, n);
        atomicLightDirAvg(parentValueIndex, d);

    }
}